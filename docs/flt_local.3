.TH "flt_local" "3" "2014-01-01" "Fleet" "Fleet\ documentation"
.SH NAME
.PP
flt_local \[en] Context\-local storage
.SH SYNOPSIS
.PP
\f[B]#include <fleet.h>\f[]
.PP
\f[B]struct flt_local\f[];
.PP
typedef void *
.PD 0
.P
.PD
(\f[B]flt_local_new_f\f[])(struct flt *\f[I]flt\f[], void *\f[I]ud\f[]);
.PP
typedef void
.PD 0
.P
.PD
(\f[B]flt_local_free_f\f[])(struct flt *\f[I]flt\f[], void *\f[I]ud\f[],
void *\f[I]instance\f[]);
.PP
struct flt_local *
.PD 0
.P
.PD
\f[B]flt_local_new\f[](struct flt *\f[I]flt\f[], void *\f[I]ud\f[],
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ \ \ \ \ \ flt_local_new_f *\f[I]new_instance\f[],
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ \ \ \ \ \ flt_local_free_f *\f[I]free_instance\f[]);
.PP
void
.PD 0
.P
.PD
\f[B]flt_local_free\f[](struct flt_local *\f[I]local\f[]);
.PP
void *
.PD 0
.P
.PD
\f[B]flt_local_get\f[](struct flt *\f[I]flt\f[], struct flt_local
*\f[I]local\f[]);
.PP
typedef void
.PD 0
.P
.PD
\f[B]flt_local_visit_f\f[](struct flt *\f[I]flt\f[], void *\f[I]ud\f[],
void *\f[I]instance\f[]);
.PP
void
.PD 0
.P
.PD
\f[B]flt_local_for_each\f[](struct flt *\f[I]flt\f[], struct flt_local
*\f[I]local\f[],
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void *\f[I]ud\f[],
flt_local_visit_f *\f[I]visitor\f[]);
.SH DESCRIPTION
.PP
The \f[B]flt_local\f[] API is analogous to thread\-local storage (TLS)
in a traditional threaded application.
It allows you to have a distinct instance of a particular data type for
each execution context in a fleet.
You provide callback functions that can allocate and deallocate an
individual instance; the \f[B]flt_local\f[] manager is then responsible
for the actual life cycle of the instances, and for providing the
instance associated with a particular execution context.
.PP
\f[B]flt_local_new\f[]() creates a new \f[B]flt_local\f[] manager.
This new manager will use \f[I]new_instance\f[] and
\f[I]free_instance\f[] to allocate and deallocate the data instances
that it manages.
Your \f[I]new_instance\f[] callback will be called exactly once for each
execution context in the fleet.
Note that your allocation function is given a pointer to the
\f[B]flt\f[](3) instance that it belongs to, in case you need to store
this somewhere in your data structure.
.PP
\f[B]flt_local_free\f[]() frees an \f[B]flt_local\f[] manager, and any
instances that it has created.
If the manager is shared among multiple tasks, you must ensure that only
one of them frees it, and only does so when all of the other tasks are
done using it.
.PP
\f[B]flt_local_get\f[]() returns the data instance for a particular
execution context.
.PP
\f[B]flt_local_for_each\f[]() calls a \f[I]visitor\f[] function once for
each of the context\-specific instances in the \f[B]flt_local\f[]
manager.
This will cause the current task to access data that is technically
owned by some other execution context; it is your responsibility to make
sure this happens in a thread\-safe manner.
You will usually use this function in a cleanup task to \[lq]merge\[rq]
partial results that were calculated in each execution context, using
one of the \f[B]flt_run_after_group\f[](3) family of functions.
.SH RETURN VALUES
.PP
\f[B]flt_local_new\f[]() will always return a valid new
\f[B]flt_local\f[] manager.
.PP
Your \f[I]new_instance\f[] callback can return any pointer value you
want, including \f[C]NULL\f[].
Your \f[I]free_instance\f[] callback must be able to handle any value
returned by your \f[I]new_instance\f[] callback.
