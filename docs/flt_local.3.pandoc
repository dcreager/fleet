% flt_local(3)

# NAME

flt_local -- Context-local storage

# SYNOPSIS

| **#include &lt;fleet.h&gt;**
|
| **struct flt_local**;
|
| typedef void \*
| (**flt_local_new_f**)(struct flt \**flt*, void \**ud*);
|
| typedef void
| (**flt_local_free_f**)(struct flt \**flt*, void \**ud*, void \**instance*);
|
| struct flt_local \*
| **flt_local_new**(struct flt \**flt*, void \**ud*,
|               flt_local_new_f \**new_instance*,
|               flt_local_free_f \**free_instance*);
|
| void
| **flt_local_free**(struct flt_local \**local*);
|
| void \*
| **flt_local_get**(struct flt \**flt*, struct flt_local \**local*);
|
| typedef void
| **flt_local_visit_f**(struct flt \**flt*, void \**ud*, void \**instance*);
|
| void
| **flt_local_for_each**(struct flt \**flt*, struct flt_local \**local*,
|                    void \**ud*, flt_local_visit_f \**visitor*);


# DESCRIPTION

The **flt_local** API is analogous to thread-local storage (TLS) in a
traditional threaded application.  It allows you to have a distinct instance of
a particular data type for each execution context in a fleet.  You provide
callback functions that can allocate and deallocate an individual instance; the
**flt_local** manager is then responsible for the actual life cycle of the
instances, and for providing the instance associated with a particular execution
context.

**flt_local_new**() creates a new **flt_local** manager.  This new manager will
use *new_instance* and *free_instance* to allocate and deallocate the data
instances that it manages.  Your *new_instance* callback will be called exactly
once for each execution context in the fleet.  Note that your allocation
function is given a pointer to the **flt**(3) instance that it belongs to, in
case you need to store this somewhere in your data structure.

**flt_local_free**() frees an **flt_local** manager, and any instances that it
has created.  If the manager is shared among multiple tasks, you must ensure
that only one of them frees it, and only does so when all of the other tasks are
done using it.

**flt_local_get**() returns the data instance for a particular execution
context.

**flt_local_for_each**() calls a *visitor* function once for each of the
context-specific instances in the **flt_local** manager.  This will cause the
current task to access data that is technically owned by some other execution
context; it is your responsibility to make sure this happens in a thread-safe
manner.  You will usually use this function in a cleanup task to “merge” partial
results that were calculated in each execution context, using one of the
**flt_run_after_group**(3) family of functions.


# RETURN VALUES

**flt_local_new**() will always return a valid new **flt_local** manager.

Your *new_instance* callback can return any pointer value you want, including
`NULL`.  Your *free_instance* callback must be able to handle any value returned
by your *new_instance* callback.
